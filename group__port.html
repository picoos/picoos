<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>pico]OS: pico]OS Porting Information</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">pico]OS
   &#160;<span id="projectnumber">1.0.4a</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pico]OS Porting Information<div class="ingroups"><a class="el" href="group__intro.html">Introduction</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad18dec8e37a90f6ed9e5fd068cc526b1"><td class="memItemLeft" align="right" valign="top">POSFROMEXT <a class="el" href="picoos_8h.html#a560fb7bf8dc2f316e50c0b8d8196d26c">UVAR_t</a> POSCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__port.html#gad18dec8e37a90f6ed9e5fd068cc526b1">p_pos_findbit</a> (const <a class="el" href="picoos_8h.html#a560fb7bf8dc2f316e50c0b8d8196d26c">UVAR_t</a> bitfield)</td></tr>
<tr class="separator:gad18dec8e37a90f6ed9e5fd068cc526b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga325cb8f12daa3e12a898a9e9a67f7b74"><td class="memItemLeft" align="right" valign="top">POSFROMEXT <a class="el" href="picoos_8h.html#a560fb7bf8dc2f316e50c0b8d8196d26c">UVAR_t</a> POSCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__port.html#ga325cb8f12daa3e12a898a9e9a67f7b74">p_pos_findbit</a> (const <a class="el" href="picoos_8h.html#a560fb7bf8dc2f316e50c0b8d8196d26c">UVAR_t</a> bitfield, <a class="el" href="picoos_8h.html#a560fb7bf8dc2f316e50c0b8d8196d26c">UVAR_t</a> rrOffset)</td></tr>
<tr class="separator:ga325cb8f12daa3e12a898a9e9a67f7b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga775910e7930891db8f173f6dd69633b8"><td class="memItemLeft" align="right" valign="top">POSFROMEXT void POSCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__port.html#ga775910e7930891db8f173f6dd69633b8">p_pos_initArch</a> (void)</td></tr>
<tr class="separator:ga775910e7930891db8f173f6dd69633b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f92fe5d53d8cd3b5b9526baff168c11"><td class="memItemLeft" align="right" valign="top">POSFROMEXT void POSCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__port.html#ga3f92fe5d53d8cd3b5b9526baff168c11">p_pos_initTask</a> (<a class="el" href="picoos_8h.html#a4529d202a1c8363a8d29cd9e1606438d">POSTASK_t</a> task, void *stackstart, <a class="el" href="picoos_8h.html#ae702996dc8e4639d29884b27b0fbf29f">POSTASKFUNC_t</a> funcptr, void *funcarg)</td></tr>
<tr class="separator:ga3f92fe5d53d8cd3b5b9526baff168c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70ddb00b2b3eac7ccaecc1e02bdd6897"><td class="memItemLeft" align="right" valign="top">POSFROMEXT <a class="el" href="picoos_8h.html#acd71b9176e3754a87ca57fc06931e0de">VAR_t</a> POSCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__port.html#ga70ddb00b2b3eac7ccaecc1e02bdd6897">p_pos_initTask</a> (<a class="el" href="picoos_8h.html#a4529d202a1c8363a8d29cd9e1606438d">POSTASK_t</a> task, <a class="el" href="picoos_8h.html#a17133269bf6f77fd6b3523d894076dbe">UINT_t</a> stacksize, <a class="el" href="picoos_8h.html#ae702996dc8e4639d29884b27b0fbf29f">POSTASKFUNC_t</a> funcptr, void *funcarg)</td></tr>
<tr class="separator:ga70ddb00b2b3eac7ccaecc1e02bdd6897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga090da72a97048dbb2067d6b221b96c0e"><td class="memItemLeft" align="right" valign="top">POSFROMEXT void POSCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__port.html#ga090da72a97048dbb2067d6b221b96c0e">p_pos_freeStack</a> (<a class="el" href="picoos_8h.html#a4529d202a1c8363a8d29cd9e1606438d">POSTASK_t</a> task)</td></tr>
<tr class="separator:ga090da72a97048dbb2067d6b221b96c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa332a78292bc10867826e247361cc130"><td class="memItemLeft" align="right" valign="top">POSFROMEXT void POSCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__port.html#gaa332a78292bc10867826e247361cc130">p_pos_lock</a> (void)</td></tr>
<tr class="separator:gaa332a78292bc10867826e247361cc130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbbcc1b0e31b3fce379f6457e6335399"><td class="memItemLeft" align="right" valign="top">POSFROMEXT void POSCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__port.html#gadbbcc1b0e31b3fce379f6457e6335399">p_pos_unlock</a> (void)</td></tr>
<tr class="separator:gadbbcc1b0e31b3fce379f6457e6335399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1de30cecad661746434d0dbd870d1c71"><td class="memItemLeft" align="right" valign="top">POSFROMEXT <a class="el" href="picoos_8h.html#acd71b9176e3754a87ca57fc06931e0de">VAR_t</a> POSCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__port.html#ga1de30cecad661746434d0dbd870d1c71">p_pos_initTask</a> (<a class="el" href="picoos_8h.html#a4529d202a1c8363a8d29cd9e1606438d">POSTASK_t</a> task, <a class="el" href="picoos_8h.html#ae702996dc8e4639d29884b27b0fbf29f">POSTASKFUNC_t</a> funcptr, void *funcarg)</td></tr>
<tr class="separator:ga1de30cecad661746434d0dbd870d1c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad73879e76ac6a794b48f424fec5b201"><td class="memItemLeft" align="right" valign="top">POSFROMEXT void POSCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__port.html#gaad73879e76ac6a794b48f424fec5b201">p_pos_startFirstContext</a> (void)</td></tr>
<tr class="separator:gaad73879e76ac6a794b48f424fec5b201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29774435bfbbb74fd003a0e3c5332af0"><td class="memItemLeft" align="right" valign="top">POSFROMEXT void POSCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__port.html#ga29774435bfbbb74fd003a0e3c5332af0">p_pos_softContextSwitch</a> (void)</td></tr>
<tr class="separator:ga29774435bfbbb74fd003a0e3c5332af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a42bf245c41c524c80a72b82fe13d76"><td class="memItemLeft" align="right" valign="top">POSFROMEXT void POSCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__port.html#ga8a42bf245c41c524c80a72b82fe13d76">p_pos_intContextSwitch</a> (void)</td></tr>
<tr class="separator:ga8a42bf245c41c524c80a72b82fe13d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f23faef9360ef15a4abd268163d0a9b"><td class="memItemLeft" align="right" valign="top">POSFROMEXT void POSCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__port.html#ga7f23faef9360ef15a4abd268163d0a9b">p_pos_intContextSwitchPending</a> (void)</td></tr>
<tr class="separator:ga7f23faef9360ef15a4abd268163d0a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga859935a2e7752b7144a470e9e3dcdbb0"><td class="memItemLeft" align="right" valign="top">POSEXTERN void POSCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__port.html#ga859935a2e7752b7144a470e9e3dcdbb0">c_pos_intEnter</a> (void)</td></tr>
<tr class="separator:ga859935a2e7752b7144a470e9e3dcdbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad290f0d4a1eecd5f09cfeded7829e187"><td class="memItemLeft" align="right" valign="top">POSEXTERN void POSCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__port.html#gad290f0d4a1eecd5f09cfeded7829e187">c_pos_intExit</a> (void)</td></tr>
<tr class="separator:gad290f0d4a1eecd5f09cfeded7829e187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5192c53a3d925629b7946b165fa5a47b"><td class="memItemLeft" align="right" valign="top">POSEXTERN void POSCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__port.html#ga5192c53a3d925629b7946b165fa5a47b">c_pos_intExitQuick</a> (void)</td></tr>
<tr class="separator:ga5192c53a3d925629b7946b165fa5a47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03edcb67afad4d0afae09a8a1bf45fd0"><td class="memItemLeft" align="right" valign="top">POSEXTERN void POSCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__port.html#ga03edcb67afad4d0afae09a8a1bf45fd0">c_pos_timerInterrupt</a> (void)</td></tr>
<tr class="separator:ga03edcb67afad4d0afae09a8a1bf45fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h3>General Information</h3>
<h4>Choose the best type of stack management</h4>
<p>The operating system can be easily ported to other architectures, it can be ported to very small 8 bit architectures with low memory and to 32 bit architectures with lots of memory. To keep the porting as simple as possible, there are only a couple of functions that must be adapted to the architecute. Before you start porting the operating system to your architecture, you must choose a stack management type. You have the choice between:<br />
 <a class="el" href="group__arch.html#ga9def726397493144392e7b945c996475">POSCFG_TASKSTACKTYPE</a> <b>= 0</b><br />
The stack memory is provided by the user. This is the best choice for very small architectures with low memory.<br />
 <a class="el" href="group__arch.html#ga9def726397493144392e7b945c996475">POSCFG_TASKSTACKTYPE</a> <b>= 1</b><br />
The stack memory is dynamically allocated by the architecture dependent code of the operating system. The size of the stack frame is variable and can be choosen by the user who creates the task. This is the best choice for big architectures with lots of memory.<br />
 <a class="el" href="group__arch.html#ga9def726397493144392e7b945c996475">POSCFG_TASKSTACKTYPE</a> <b>= 2</b><br />
The stack memory is dynamically allocated by the architecture dependent code of the operating system. The size of the stack frame is fixed and can not be changed by the user. This may be an alternative to type 0, it is a little bit more user friendly.<br />
 Here is a list of the functions that are architecture specific and must be ported:<br />
<a class="el" href="group__port.html#ga3f92fe5d53d8cd3b5b9526baff168c11">p_pos_initTask</a>, <a class="el" href="group__port.html#gaad73879e76ac6a794b48f424fec5b201">p_pos_startFirstContext</a>, <a class="el" href="group__port.html#ga29774435bfbbb74fd003a0e3c5332af0">p_pos_softContextSwitch</a>, <a class="el" href="group__port.html#ga8a42bf245c41c524c80a72b82fe13d76">p_pos_intContextSwitch</a>.<br />
 If you choose <a class="el" href="group__arch.html#ga9def726397493144392e7b945c996475">POSCFG_TASKSTACKTYPE</a> <b>= 2</b> or <b>3</b>, you must also provide the function <a class="el" href="group__port.html#ga090da72a97048dbb2067d6b221b96c0e">p_pos_freeStack</a>.<br />
<br />
<br />
 </p><h4>Get more speed with optimized "findbit" function</h4>
<p>If your application is critical in performance, you may also provide an assembler version of the function "findbit". There are two different function prototypes possible. The simple prototype for the standard scheduling scheme (<a class="el" href="group__coreset.html#ga305b0897b2cf4dbf73540bfd410821d6">POSCFG_ROUNDROBIN</a> <b>= 0</b>) is<br />
 <b>UVAR_t <a class="el" href="group__port.html#gad18dec8e37a90f6ed9e5fd068cc526b1">p_pos_findbit(const UVAR_t bitfield)</a>;</b></p>
<p>The prototype for a findbit function that supports round robin scheduling (<a class="el" href="group__coreset.html#ga305b0897b2cf4dbf73540bfd410821d6">POSCFG_ROUNDROBIN</a> <b>= 1</b>) is<br />
 <b>UVAR_t <a class="el" href="group__port.html#ga325cb8f12daa3e12a898a9e9a67f7b74">p_pos_findbit(const UVAR_t bitfield, UVAR_t rrOffset)</a>;</b><br />
 The function gets a bitfield as input, and returns the number of the right most set bit (that is the number of the first lsb that is set). If round robin is enabled, the function takes an offset as second parameter. The offset is the position where the function starts to search the first set bit. The function scans the bitfield always from right to left, starting with the bit denoted by the offset. The bitfield is seen as circle, when the rightmost bit is not set the function must continue scanning the leftmost bit (wrap around), so all bits of the field are scanned.<br />
It is possible to implement the findbit mechanism as look up table. For this purpose you can define the macro <b>FINDBIT</b>. Please see the header file <a class="el" href="picoos_8h.html" title="pico]OS main include file ">picoos.h</a> (search for the word <a class="el" href="group__findbit.html#ga8fe1d3072c4af08739832bd599dade9b">POSCFG_FBIT_USE_LUTABLE</a>) and the source file fbit_gen.c for details.<br />
 <br />
</p><h3>Assembler Functions</h3>
<p>Unfortunately, not the whole operating system can be written in C. The platform port must be written in assembly language. I tried to keep the assembly part of the RTOS as small as possible. But there are three assembly functions left, that are needed for doing the context switching:<br />
</p><ul>
<li><a class="el" href="group__port.html#gaad73879e76ac6a794b48f424fec5b201">p_pos_startFirstContext</a></li>
<li><a class="el" href="group__port.html#ga29774435bfbbb74fd003a0e3c5332af0">p_pos_softContextSwitch</a></li>
<li><a class="el" href="group__port.html#ga8a42bf245c41c524c80a72b82fe13d76">p_pos_intContextSwitch</a></li>
</ul>
<p>The operating system requires also a timer interrupt that is used to cut the task execution time into slices. Hardware interrupts must comply with some conventions to be compatible to pico]OS. So the fourth thing you need to write in assember is a framework for hardware interrupts.<br />
 The diagram shows the assembler functions in logical structure. At the left side I have drawn a normal interrupt service routine for reference.<br />
<br />
<br />
 </p>
<div class="image">
<img src="../pic/portfc1.png"  align="middle" border="0"/>
</div>
<p><br />
 The context switching (multitasking) is done by simply swaping the stack frame when an interrupt service routine (eg. the timer interrupt) is left. But it must also be possible for a task to give of processing time without the need of an interrupt. This is done by the function <a class="el" href="group__port.html#ga29774435bfbbb74fd003a0e3c5332af0">p_pos_softContextSwitch</a> at the right side in the diagram. Since this function is not called by a processor interrupt, it must build up an ISR compatible stack frame by itself. Note that the second part of this function is equal to the function <a class="el" href="group__port.html#ga8a42bf245c41c524c80a72b82fe13d76">p_pos_intContextSwitch</a>, so the function must be terminated by an return-from-interrupt instruction, even if the function was called from a C-routine.<br />
 For completeness, the next diagram shows at its left side how the function <a class="el" href="group__port.html#gaad73879e76ac6a794b48f424fec5b201">p_pos_startFirstContext</a> works. Again, this function looks like the lower part of the funtion <a class="el" href="group__port.html#ga8a42bf245c41c524c80a72b82fe13d76">p_pos_intContextSwitch</a> in the diagram above. In the middle you can see how the timer interrupt routine must look like.<br />
<br />
<br />
 </p>
<div class="image">
<img src="../pic/portfc2.png"  align="middle" border="0"/>
</div>
<p><br />
 There is a special interrupt handling needed when interrupts are interruptable on your system. To prevent a deadlock situation (that is, an ISR would be called again and again until the stack flows over), a counting flag variable is exported by pico]OS: <a class="el" href="picoos_8h.html#acff307fe2f3f00d7badb582ff4ab2897" title="Global flag variable. This variable is nonzero when the CPU is currently executing an interrupt servi...">posInInterrupt_g</a>. This variable contains the value zero if no interrupt is running yet. And only if no other interrupt is running, the ISR must save the stack pointer to the task environment structure where <a class="el" href="picoos_8h.html#afed0dbeed05c3fb45c5b39aa85898fa2" title="Global task variable. This variable points to the environment structure of the currently active task...">posCurrentTask_g</a> points to. This behaviour is shown at the right side in the diagram above.<br />
 Note that interrupt service routines need some stack space to be able to do their work - in the discussed configuration every ISR would take some stack memory from the stack frame of the currently active task. But this may be a problem at platforms that are low on memory - it would be to expensive to increase every tasks stack frame by the count of bytes an ISR would need. In this case, you can set up a special stackframe that is only used by interrupt service routines. The diagram below shows the small changes to the ISRs discussed above. But attention - this method is only applicable on platforms where interrupts can not interrupt each other.<br />
<br />
<br />
 </p>
<div class="image">
<img src="../pic/portfc3.png"  align="middle" border="0"/>
</div>
<p><br />
</p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga859935a2e7752b7144a470e9e3dcdbb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">POSEXTERN void POSCALL c_pos_intEnter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interrupt control function. This function must be called from an interrupt service routine to show the operating system that an ISR is currently running. This function must be called first before other operating system functions can be called from within the ISR. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__port.html#gad290f0d4a1eecd5f09cfeded7829e187">c_pos_intExit</a>, <a class="el" href="group__port.html#ga03edcb67afad4d0afae09a8a1bf45fd0">c_pos_timerInterrupt</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad290f0d4a1eecd5f09cfeded7829e187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">POSEXTERN void POSCALL c_pos_intExit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interrupt control function. This function must be called from an interrupt service routine to show the operating system that the ISR is going to complete its work and no operating system functions will be called any more from within the ISR. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__port.html#ga859935a2e7752b7144a470e9e3dcdbb0">c_pos_intEnter</a>, <a class="el" href="group__port.html#ga03edcb67afad4d0afae09a8a1bf45fd0">c_pos_timerInterrupt</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5192c53a3d925629b7946b165fa5a47b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">POSEXTERN void POSCALL c_pos_intExitQuick </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interrupt control function. Similar to c_pos_intExit, except that context switch is not performed. Instead, a call to p_pos_intContextSwitchQueue is performed if it is necessary to perform task scheduling. p_pos_intContextSwitchQueue should "queue" context switch to occur at later time.</p>
<p>This was needed for Arm Cortex-M cpus, which need to use PendSV exception for context switching. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__port.html#gad290f0d4a1eecd5f09cfeded7829e187">c_pos_intExit</a>, p_pos_intContextSwitchQueue </dd></dl>

</div>
</div>
<a class="anchor" id="ga03edcb67afad4d0afae09a8a1bf45fd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">POSEXTERN void POSCALL c_pos_timerInterrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timer interrupt control function. This function must be called periodically from within a timer interrupt service routine. The whole system timing is derived from this timer interrupt.<br />
 A timer ISR could look like this:<br />
 </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;PUSH ALL; // push all registers to stack@n</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;if (posInInterrupt_g == 0)</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  saveStackptrToCurrentTaskEnv();</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;c_pos_intEnter();</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;c_pos_timerInterrupt();</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;c_pos_intExit();</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;PULL ALL; // pull all registers from stack@n</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;RETI;     // return from interrupt@n</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Any other ISR looks like this, only the function <a class="el" href="group__port.html#ga03edcb67afad4d0afae09a8a1bf45fd0">c_pos_timerInterrupt</a> is replaced by an user function.<br />
 Dependent on the platform port, it can be necessary to evaluate the variable <a class="el" href="picoos_8h.html#a492a4358cee590c1969413bc23abafb7" title="Global flag variable. This variable is nonzero when the operating system is initialized and running...">posRunning_g</a> to ensure that the timer interrupt is not triggered when the OS is not yet running.<br />
 To avoid this race condintions, it is better to initialize the timer interrupt in the function <a class="el" href="group__port.html#gaad73879e76ac6a794b48f424fec5b201">p_pos_startFirstContext</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__port.html#ga859935a2e7752b7144a470e9e3dcdbb0">c_pos_intEnter</a>, <a class="el" href="group__port.html#gad290f0d4a1eecd5f09cfeded7829e187">c_pos_intExit</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad18dec8e37a90f6ed9e5fd068cc526b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">POSFROMEXT <a class="el" href="picoos_8h.html#a560fb7bf8dc2f316e50c0b8d8196d26c">UVAR_t</a> POSCALL p_pos_findbit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="picoos_8h.html#a560fb7bf8dc2f316e50c0b8d8196d26c">UVAR_t</a>&#160;</td>
          <td class="paramname"><em>bitfield</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bit finding function. This function is called by the operating system to find the first set bit in a bitfield. See the file fbit_gen.c for an example. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitfield</td><td>This is the bitfield that shall be scanned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of the first set bit (scanning begins with the lsb). </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__coreset.html#ga305b0897b2cf4dbf73540bfd410821d6">POSCFG_ROUNDROBIN</a> <b>must be defined to 0</b> to have this format of the function compiled in. </dd></dl>

</div>
</div>
<a class="anchor" id="ga325cb8f12daa3e12a898a9e9a67f7b74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">POSFROMEXT <a class="el" href="picoos_8h.html#a560fb7bf8dc2f316e50c0b8d8196d26c">UVAR_t</a> POSCALL p_pos_findbit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="picoos_8h.html#a560fb7bf8dc2f316e50c0b8d8196d26c">UVAR_t</a>&#160;</td>
          <td class="paramname"><em>bitfield</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="picoos_8h.html#a560fb7bf8dc2f316e50c0b8d8196d26c">UVAR_t</a>&#160;</td>
          <td class="paramname"><em>rrOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bit finding function. This function is called by the operating system to find the first set bit in a bitfield. See the file fbit_gen.c for an example. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitfield</td><td>This is the bitfield that shall be scanned. </td></tr>
    <tr><td class="paramname">rrOffset</td><td>Offset into the bitfield. Scanning begins here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of the first set bit (scanning begins with the lsb). </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__coreset.html#ga305b0897b2cf4dbf73540bfd410821d6">POSCFG_ROUNDROBIN</a> <b>must be defined to 1</b> to have this format of the function compiled in. </dd></dl>

</div>
</div>
<a class="anchor" id="ga090da72a97048dbb2067d6b221b96c0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">POSFROMEXT void POSCALL p_pos_freeStack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="picoos_8h.html#a4529d202a1c8363a8d29cd9e1606438d">POSTASK_t</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stack free function. This function is called by the operating system to free a stack frame that was set up by the function <a class="el" href="group__port.html#ga3f92fe5d53d8cd3b5b9526baff168c11">p_pos_initTask</a>. See the available port source files for an example on how to write this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>pointer to the task environment structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__arch.html#ga9def726397493144392e7b945c996475">POSCFG_TASKSTACKTYPE</a> <b>must be defined to 1 or 2</b> to have this format of the function compiled in.<br />
 This function is not part of the pico]OS. It must be provided by the user, since it is architecture specific.<br />
 The processor interrupts are disabled when this function is called; but the processor may still write some bytes to the stack frame after this function was called and before the interrupts are enabled again. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__port.html#ga3f92fe5d53d8cd3b5b9526baff168c11">p_pos_initTask</a></dd></dl>
<p>Stack free function. This function is called by the operating system to free a stack frame that was set up by the function <a class="el" href="group__port.html#ga3f92fe5d53d8cd3b5b9526baff168c11">p_pos_initTask</a>. See the available port source files for an example on how to write this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>pointer to the task environment structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__arch.html#ga9def726397493144392e7b945c996475">POSCFG_TASKSTACKTYPE</a> <b>must be defined to 1 or 2</b> to have this format of the function compiled in.<br />
 This function is not part of the pico]OS. It must be provided by the user, since it is architecture specific.<br />
 The processor interrupts are disabled when this function is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__port.html#ga3f92fe5d53d8cd3b5b9526baff168c11">p_pos_initTask</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga775910e7930891db8f173f6dd69633b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">POSFROMEXT void POSCALL p_pos_initArch </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Architecture port initialization. This function is called from the <a class="el" href="group__task.html#ga45606789e609e1c35edcb64adb9f43f5">posInit</a> function to initialize the architecture specific part of the operating system. </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="group__arch.html#ga5e1c3a7349532e1e6cb02daf41e2d6e9">POSCFG_CALLINITARCH</a> must be defined to 1 when <a class="el" href="group__task.html#ga45606789e609e1c35edcb64adb9f43f5">posInit</a> shall call this function.<br />
 This function is not part of the pico]OS. It must be provided by the user, since it is architecture specific.<br />
 A timer interrupt should be initialized in the funcion <a class="el" href="group__port.html#gaad73879e76ac6a794b48f424fec5b201">p_pos_startFirstContext</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f92fe5d53d8cd3b5b9526baff168c11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">POSFROMEXT void POSCALL p_pos_initTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="picoos_8h.html#a4529d202a1c8363a8d29cd9e1606438d">POSTASK_t</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stackstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="picoos_8h.html#ae702996dc8e4639d29884b27b0fbf29f">POSTASKFUNC_t</a>&#160;</td>
          <td class="paramname"><em>funcptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>funcarg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Task initialization function. This function is called by the operating system to initialize the stack frame of a new task. See the available port source files for an example on how to write this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>pointer to the task environment structure. </td></tr>
    <tr><td class="paramname">stackstart</td><td>pointer to the start of the stack memory. </td></tr>
    <tr><td class="paramname">funcptr</td><td>pointer to the first function that shall be executed by the new task. </td></tr>
    <tr><td class="paramname">funcarg</td><td>argument that should be passed to the first function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__arch.html#ga9def726397493144392e7b945c996475">POSCFG_TASKSTACKTYPE</a> <b>must be defined to 0</b> to have this format of the function compiled in.<br />
 This function is not part of the pico]OS. It must be provided by the user, since it is architecture specific.<br />
 The processor interrupts are disabled when this function is called. </dd></dl>

</div>
</div>
<a class="anchor" id="ga70ddb00b2b3eac7ccaecc1e02bdd6897"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">POSFROMEXT <a class="el" href="picoos_8h.html#acd71b9176e3754a87ca57fc06931e0de">VAR_t</a> POSCALL p_pos_initTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="picoos_8h.html#a4529d202a1c8363a8d29cd9e1606438d">POSTASK_t</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="picoos_8h.html#a17133269bf6f77fd6b3523d894076dbe">UINT_t</a>&#160;</td>
          <td class="paramname"><em>stacksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="picoos_8h.html#ae702996dc8e4639d29884b27b0fbf29f">POSTASKFUNC_t</a>&#160;</td>
          <td class="paramname"><em>funcptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>funcarg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Task initialization function. This function is called by the operating system to initialize the stack frame of a new task. See the available port source files for an example on how to write this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>pointer to the task environment structure. </td></tr>
    <tr><td class="paramname">stacksize</td><td>size of the stack memory for the new task. The stack memory may be allocated dynamically from within this function. </td></tr>
    <tr><td class="paramname">funcptr</td><td>pointer to the first function that shall be executed by the new task. </td></tr>
    <tr><td class="paramname">funcarg</td><td>argument that should be passed to the first function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on success. A negative value should be returned to denote an error (e.g. out of stack memory). </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__arch.html#ga9def726397493144392e7b945c996475">POSCFG_TASKSTACKTYPE</a> <b>must be defined to 1</b> to have this format of the function compiled in.<br />
 This function is not part of the pico]OS. It must be provided by the user, since it is architecture specific.<br />
 The processor interrupts are disabled when this function is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__port.html#ga090da72a97048dbb2067d6b221b96c0e">p_pos_freeStack</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1de30cecad661746434d0dbd870d1c71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">POSFROMEXT <a class="el" href="picoos_8h.html#acd71b9176e3754a87ca57fc06931e0de">VAR_t</a> POSCALL p_pos_initTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="picoos_8h.html#a4529d202a1c8363a8d29cd9e1606438d">POSTASK_t</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="picoos_8h.html#ae702996dc8e4639d29884b27b0fbf29f">POSTASKFUNC_t</a>&#160;</td>
          <td class="paramname"><em>funcptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>funcarg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Task initialization function. This function is called by the operating system to initialize the stack frame of a new task. This function is responsible to allocate the stack memory and to store the pointer of the stack frame into the task environment. See the available port source files for an example on how to write this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>pointer to the task environment structure. </td></tr>
    <tr><td class="paramname">funcptr</td><td>pointer to the first function that shall be executed by the new task. </td></tr>
    <tr><td class="paramname">funcarg</td><td>argument that should be passed to the first function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on success. A negative value should be returned to denote an error (e.g. out of stack memory). </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__arch.html#ga9def726397493144392e7b945c996475">POSCFG_TASKSTACKTYPE</a> <b>must be defined to 2</b> to have this format of the function compiled in.<br />
 This function is not part of the pico]OS. It must be provided by the user, since it is architecture specific.<br />
 The processor interrupts are disabled when this function is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__port.html#ga090da72a97048dbb2067d6b221b96c0e">p_pos_freeStack</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8a42bf245c41c524c80a72b82fe13d76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">POSFROMEXT void POSCALL p_pos_intContextSwitch </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Context switch function. This function is called by the operating system to initiate a context switch from interrupt level. This function has then to switch the context variable and restore the new context from stack memory. See the available port source files for an example on how to write this function. </p><dl class="section note"><dt>Note</dt><dd>This function is not part of the pico]OS. It must be provided by the user, since it is architecture specific. The processor interrupts are disabled when this function is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__port.html#ga29774435bfbbb74fd003a0e3c5332af0">p_pos_softContextSwitch</a>, <a class="el" href="group__port.html#gaad73879e76ac6a794b48f424fec5b201">p_pos_startFirstContext</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f23faef9360ef15a4abd268163d0a9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">POSFROMEXT void POSCALL p_pos_intContextSwitchPending </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Context switch function. Called by c_pos_intExitQuick if task scheduling is needed. This function should queue context switch somehow, for example in Arm Cortex-M CPU:s a PendSV exception can be set pending. </p><dl class="section note"><dt>Note</dt><dd>This function is not part of the pico]OS. It must be provided by the user, since it is architecture specific. The processor interrupts are disabled when this function is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__port.html#ga29774435bfbbb74fd003a0e3c5332af0">p_pos_softContextSwitch</a>, <a class="el" href="group__port.html#ga5192c53a3d925629b7946b165fa5a47b">c_pos_intExitQuick</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa332a78292bc10867826e247361cc130"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">POSFROMEXT void POSCALL p_pos_lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Port lock. In some really special cases it may be required that Pico]OS must acquire a mutex before it can call the functions <a class="el" href="group__port.html#ga3f92fe5d53d8cd3b5b9526baff168c11">p_pos_initTask</a> and <a class="el" href="group__port.html#ga090da72a97048dbb2067d6b221b96c0e">p_pos_freeStack</a>. If you need such a mutex for your port, please define <a class="el" href="group__arch.html#ga2a9f848214e56f69075e1dd798c0a717">POSCFG_PORTMUTEX</a> to 1. Then implement the both functions <a class="el" href="group__port.html#gaa332a78292bc10867826e247361cc130">p_pos_lock</a> and p_pos_unlock in your arch_c.c file. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__port.html#gadbbcc1b0e31b3fce379f6457e6335399">p_pos_unlock</a>, <a class="el" href="group__arch.html#ga2a9f848214e56f69075e1dd798c0a717">POSCFG_PORTMUTEX</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga29774435bfbbb74fd003a0e3c5332af0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">POSFROMEXT void POSCALL p_pos_softContextSwitch </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Context switch function. This function is called by the operating system to initiate a software context switch. This function has then to save all volatile processor registers to stack memory, switch the context variable and restore the new context from stack memory. See the available port source files for an example on how to write this function. </p><dl class="section note"><dt>Note</dt><dd>This function is not part of the pico]OS. It must be provided by the user, since it is architecture specific.<br />
 The processor interrupts are disabled when this function is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__port.html#ga8a42bf245c41c524c80a72b82fe13d76">p_pos_intContextSwitch</a>, <a class="el" href="group__port.html#gaad73879e76ac6a794b48f424fec5b201">p_pos_startFirstContext</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaad73879e76ac6a794b48f424fec5b201"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">POSFROMEXT void POSCALL p_pos_startFirstContext </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Context switch function. This function is called by the operating system to start the multitasking. The function has to restore the first context from stack memory. See the available port source files for an example on how to write this function. </p><dl class="section note"><dt>Note</dt><dd>This function is not part of the pico]OS. It must be provided by the user, since it is architecture specific.<br />
 The processor interrupts are disabled when this function is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__port.html#ga29774435bfbbb74fd003a0e3c5332af0">p_pos_softContextSwitch</a>, <a class="el" href="group__port.html#ga8a42bf245c41c524c80a72b82fe13d76">p_pos_intContextSwitch</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadbbcc1b0e31b3fce379f6457e6335399"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">POSFROMEXT void POSCALL p_pos_unlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Port unlock. Counterpart of function <a class="el" href="group__port.html#gaa332a78292bc10867826e247361cc130">p_pos_lock</a>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 8 2015 21:54:47 for pico]OS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
